name: Pure GitHub CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  # 1. Сборка и Юнит-тесты
  build-and-unit-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: { node-version: '18' }
      - name: Install Dependencies
        run: npm ci
      - name: Run Unit Tests
        run: npm test
        env:
          NODE_ENV: test
          JWT_SECRET: ${{ secrets.JWT_SECRET }}

  # 2. Запуск "Staging" сервера и интеграционные тесты
  integration-test:
    runs-on: ubuntu-latest
    needs: build-and-unit-test
    services:
      # Запускаем PostgreSQL в контейнере для тестов (опционально)
      postgres:
        image: postgres:13
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: { node-version: '18' }
      - name: Install Dependencies
        run: npm ci
      - name: Start Server in Background
        run: |
          # Устанавливаем переменные окружения для локального сервера
          export NODE_ENV=test
          export DB_HOST=localhost
          export DB_USER=postgres
          export DB_PASSWORD=postgres
          export DB_NAME=test_db
          export JWT_SECRET=test-jwt-secret-for-ci
          # Запускаем сервер в фоне. Флаг -A для избежания блокировки.
          nohup node server.js > server.log 2>&1 &
          echo $! > server.pid
          sleep 5 # Даем серверу время на запуск
          echo "Server started. Checking logs:"
          cat server.log
      - name: Run Integration Tests
        run: |
          # Запускаем интеграционные тесты против локального сервера
          npm run test:integration
          # ИЛИ явно: npx jest __tests__/integration/ --testEnvironment=node
      - name: Stop Background Server
        if: always() # Останавливаем сервер в любом случае
        run: |
          if [ -f server.pid ]; then
            kill $(cat server.pid) 2>/dev/null || true
            rm -f server.pid
          fi
      - name: Upload Server Logs (for debugging)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: server-logs
          path: server.log

  # 3. Создание артефакта (условный "деплой")
  create-artifact:
    runs-on: ubuntu-latest
    needs: integration-test
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with: { node-version: '18' }
      - name: Install Dependencies (production only)
        run: npm ci --only=production
      - name: Create Deployment Artifact
        run: |
          # Создаем чистую папку с кодом для "деплоя"
          mkdir -p deploy_artifact
          # Копируем только необходимое (исключаем тесты, конфиги для разработки)
          cp -r app server.js package.json deploy_artifact/
          # Можно добавить дополнительные шаги: минификацию, сборку и т.д.
          echo "Artifact created at $(pwd)/deploy_artifact"
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-deployment-bundle
          path: deploy_artifact/
          retention-days: 7

  # 4. Условный "Production Deploy" (имитация)
  # В реальности здесь может быть скрипт, загружающий артефакт на ваш сервер.
  # Для демонстрации просто отметим успех.
  deploy-success:
    runs-on: ubuntu-latest
    needs: create-artifact
    environment: production # Используем Environments GitHub для наглядности
    steps:
      - name: Simulate Production Deployment
        run: |
          echo "✅ All checks passed! The artifact is ready for deployment."
          echo "In a real scenario, the code from the 'app-deployment-bundle' artifact"
          echo "would now be deployed to the production server (e.g., via SSH, FTP, etc.)."